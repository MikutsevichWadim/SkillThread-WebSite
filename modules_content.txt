-------------------- File: .\export_modules.py --------------------
import os

def export_modules_to_file(output_filename="modules_content.txt", excluded_directories=None, allowed_extensions=None):
	"""
	Exports the content of text files in the current directory and its subdirectories
	(excluding specified directories) to a single output file.

	Args:
		output_filename (str, optional): The name of the output file. Defaults to "modules_content.txt".
		excluded_directories (list of str, optional): A list of directory names to exclude.
													Defaults to None (no directories excluded).
		allowed_extensions (list of str, optional): A list of file extensions to include (e.g., ['.py', '.txt']).
													 If None, all files are considered (with extension filtering).
	"""
	
	if excluded_directories is None:
		excluded_directories = []
	if allowed_extensions is None:
		allowed_extensions = ['.py', '.txt', '.ini', '.conf', '.json', '.html', '.css', '.js', '.md', '.rst'] # Common text file extensions
	
	with open(output_filename, 'w', encoding='utf-8') as outfile:
		for root, dirs, files in os.walk('.'):  # Start walking from the current directory
			
			# Robustly exclude directories by checking if the current root path starts with any excluded directory
			if any(root.startswith(os.path.join('.', excluded_dir)) for excluded_dir in excluded_directories):
				continue  # Skip this entire directory and its subdirectories
			
			for filename in files:
				if not any(filename.lower().endswith(ext) for ext in allowed_extensions):
					continue # Skip files that don't have allowed extensions
				
				filepath = os.path.join(root, filename)
				
				try:
					with open(filepath, 'r', encoding='utf-8') as infile:
						content = infile.read()
						
						outfile.write(f"-------------------- File: {filepath} --------------------\n")
						outfile.write(content)
						outfile.write("\n\n") # Add some spacing between files
				
				except Exception as e:
					outfile.write(f"Error reading file: {filepath} - {e}\n\n")
	
	print(f"Content of modules exported to: {output_filename}")

if __name__ == "__main__":
	# Example usage: Exclude directories and specify allowed file extensions
	exclude_dirs = [".venv",'alembic', "__pycache__", ".git", ".idea"] # Directories to exclude
	allowed_file_extensions = ['.py', '.txt', '.ini'] # Only export these file types (add more if needed)
	export_modules_to_file(excluded_directories=exclude_dirs, allowed_extensions=allowed_file_extensions)


-------------------- File: .\manage.py --------------------
#!/usr/bin/env python
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'skillthread.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


-------------------- File: .\modules_content.txt --------------------


-------------------- File: .\requirements.txt --------------------
asgiref==3.8.1
asttokens==3.0.0
bleach==6.2.0
certifi==2024.12.14
charset-normalizer==3.4.1
colorama==0.4.6
decorator==5.1.1
Django==5.1.4
django-crispy-forms==2.3
django-debug-toolbar==4.4.6
django-extensions==3.2.3
django-model-utils==5.0.0
django-polymorphic==3.1.0
django-stubs==5.1.1
django-stubs-ext==5.1.1
docopt==0.6.2
executing==2.1.0
graphviz==0.20.3
idna==3.10
ipython==8.30.0
jedi==0.19.2
Markdown==3.7
matplotlib-inline==0.1.7
mysqlclient==2.2.6
packaging==24.2
parso==0.8.4
pillow==11.0.0
prompt_toolkit==3.0.48
pure_eval==0.2.3
Pygments==2.18.0
requests==2.32.3
setuptools==75.6.0
sqlparse==0.5.3
stack-data==0.6.3
traitlets==5.14.3
types-PyYAML==6.0.12.20240917
typing_extensions==4.12.2
tzdata==2024.2
urllib3==2.3.0
wcwidth==0.2.13
webencodings==0.5.1
yarg==0.1.10


-------------------- File: .\app\admin.py --------------------
from django.contrib import admin

from . import models


admin.site.register(
	model_or_iterable=[
	],
)


-------------------- File: .\app\apps.py --------------------
from django.apps import AppConfig


class AppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'app'


-------------------- File: .\app\models.py --------------------
from datetime import (
	datetime,
	timezone,
)

from django.contrib.auth import get_user_model
from django.db import models
from django.urls import reverse
from django.utils.timezone import now


-------------------- File: .\app\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\app\urls.py --------------------
from django.urls import path

from . import views

urlpatterns = [
	path(
		route='',
		view=views.Index.as_view(),
		name='index',
	),
]


-------------------- File: .\app\views.py --------------------
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.views import LoginView
from django.core.paginator import Paginator
from django.http import (
	HttpRequest,
	HttpResponse,
)
from django.shortcuts import (
	get_object_or_404,
	render,
)
from django.views import View
from django.views.generic import ListView

from channels.models import Channel
from posts.models import Post


class Index(
	ListView,
):
	model = Channel
	template_name = 'app/index.html'
	context_object_name = 'channel_list'
	paginate_by = 10
	
	def get_queryset(
		self
	):
		return Channel.popular.popular_channels()


class ErrorHandlerView(
	View
):
	template_name = 'app/error-base.html'  # Используем общий шаблон
	
	def get_context_data(
		self,
		error_code,
		error_message
	):
		return {
			'error_code': error_code,
			'error_message': error_message,
		}
	
	def get(
		self,
		request,
		*args,
		**kwargs
	):
		error_code = kwargs.get(
			'error_code',
			500
		)  # Код ошибки по умолчанию 500
		if error_code == 404:
			error_message = 'Страница не найдена'
		elif error_code == 500:
			error_message = 'Произошла ошибка на сервере'
		else:
			error_message = 'Неизвестная ошибка'
		
		context = self.get_context_data(
			error_code=error_code,
			error_message=error_message
		)
		return render(
			request,
			self.template_name,
			context,
			status=error_code
		)


-------------------- File: .\app\__init__.py --------------------


-------------------- File: .\app\templatetags\app_tags.py --------------------
import importlib

from django import template

register = template.Library()


@register.inclusion_tag(
	filename='channels/card.html'
)
def show_channel_card(
	channel,
	user,
):
	return {
		'channel': channel,
		'user': user,
	}


@register.inclusion_tag(
	filename='app/include/form-footer.html'
)
def show_form_footer(
	submit_button_inner,
):
	return {
		'submit_button_inner': submit_button_inner,
	}


@register.inclusion_tag(
	filename='app/include/form-header.html'
)
def show_form_header(
	form_title,
):
	return {
		'form_title': form_title,
	}

@register.filter(name='is_instance_of')
def is_instance_of(value, class_path):
	try:
		# Разбиваем строку на модуль и класс
		module_name, class_name = class_path.rsplit('.', 1)
		
		# Динамически импортируем модуль
		module = importlib.import_module(module_name)
		
		# Получаем класс из модуля
		class_ = getattr(module, class_name)
		
		# Проверяем, является ли объект экземпляром этого класса
		return isinstance(value, class_)
	except KeyError:
		return False


-------------------- File: .\app\templatetags\__init__.py --------------------


-------------------- File: .\channels\admin.py --------------------
from django.contrib import admin

from channels.forms import ChannelForm
from channels.models import (
	Channel,
)


@admin.register(Channel)
class ChannelAdmin(
	admin.ModelAdmin,
):
	form = ChannelForm


-------------------- File: .\channels\apps.py --------------------
from django.apps import AppConfig


class ChannelsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'channels'


-------------------- File: .\channels\forms.py --------------------
from django import forms

from channels.models import Channel


class ChannelForm(forms.ModelForm):
	name = forms.CharField(
		label='Название',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	description = forms.CharField(
		label='Описание',
		widget=forms.Textarea(
			attrs={
				'class': 'form-control',
				'rows': 1,
			},
		),
		required=False
	)
	image = forms.FileField(
		label='Иконка канала',
		widget=forms.ClearableFileInput(
			attrs={
				'class': 'form-control channel-image',
			},
		),
		required=False
	)
	class Meta:
		model = Channel
		fields = [
			'image',
			'name',
			'description',
		]


-------------------- File: .\channels\mixins.py --------------------
from django.http import (
	Http404,
	HttpResponseForbidden,
)
from django.shortcuts import get_object_or_404

from channels.models import Channel


class ChannelCreatorRequiredMixin:
	"""
	Миксин для проверки, что объект принадлежит текущему пользователю.
	Если объект не принадлежит пользователю, то будет возвращен ответ 403 (Forbidden).
	"""
	def dispatch(self, request, *args, **kwargs):
		# Получаем объект, к которому осуществляется доступ
		obj = self.get_object()  # Получение объекта через стандартный метод get_object
		# Проверяем, что объект принадлежит текущему пользователю
		if obj.created_by != request.user:
			# Возвращаем ответ с ошибкой 403, если объект не принадлежит пользователю
			return HttpResponseForbidden("Вы не имеете прав доступа к этому объекту.")
		# Если проверка прошла успешно, передаем управление дальше
		return super().dispatch(request, *args, **kwargs)


class ChannelParticipantRequiredMixin:
	"""
	Миксин для проверки, что объект принадлежит текущему пользователю.
	"""
	def dispatch(self, request, *args, **kwargs):
		# Получаем канал по ID, который передается в URL
		channel = get_object_or_404(Channel, id=kwargs['channel_id'])
		
		# Проверяем, является ли текущий пользователь участником канала
		if not channel.participants.filter(id=request.user.id).exists():
			return HttpResponseForbidden("Вы не являетесь участником этого канала.")
		
		return super().dispatch(request, *args, **kwargs)

class ChannelCreatorRequired2Mixin:
	"""
	Миксин для проверки, что объект принадлежит текущему пользователю.
	Если объект не принадлежит пользователю, то будет возвращен ответ 403 (Forbidden).
	"""
	def dispatch(self, request, *args, **kwargs):
		# Извлекаем channel_id из URL
		channel_id = kwargs.get('channel_id')
		
		# Получаем объект канала через get_object_or_404
		channel = get_object_or_404(Channel, pk=channel_id)
		
		# Проверяем, что канал принадлежит текущему пользователю
		if channel.created_by != request.user:
			# Возвращаем ответ с ошибкой 403, если объект не принадлежит пользователю
			return HttpResponseForbidden("Вы не имеете прав доступа к этому объекту.")
		
		# Если проверка прошла успешно, передаем управление дальше
		return super().dispatch(request, *args, **kwargs)


class ChannelMembershipRequiredMixin:
	"""
	Миксин для проверки, что объект принадлежит текущему пользователю.
	"""
	def dispatch(self, request, *args, **kwargs):
		# Получаем канал по ID, который передается в URL
		channel = get_object_or_404(Channel, id=kwargs['channel_id'])
		
		if request.user not in {channel.created_by, *channel.participants.all()}:
			return HttpResponseForbidden("Вы не являетесь участником этого канала.")
		
		return super().dispatch(request, *args, **kwargs)


-------------------- File: .\channels\models.py --------------------
from django.contrib.auth import get_user_model
from django.db import models
from django.urls import reverse


class ChannelMembersManager(models.Manager):
	def get_channel_members(self, channel_id):
		# Получаем канал по id
		channel = self.get(id=channel_id)
		
		# Создаем список всех пользователей, связанных с каналом
		users = set()
		
		# Добавляем создателя канала
		users.add(channel.created_by)
		
		# Добавляем авторов канала
		users.update(channel.authors.all())
		
		# Добавляем участников канала
		users.update(channel.participants.all())
		
		return users


class ChannelPopularManager(models.Manager):
	def popular_channels(self):
		return self.order_by('-visits_count')


class Channel(
	models.Model,
):
	# MANAGERS
	objects = models.Manager()
	popular = ChannelPopularManager()
	objects_members = ChannelMembersManager()
	
	# FIELDS
	created_by = models.ForeignKey(
		to=get_user_model(),
		related_name='created_channels',
		on_delete=models.SET_NULL,
		null=True,
	)
	# authors = models.ManyToManyField(
	# 	to=get_user_model(),
	# 	related_name='author_channels',
	# )
	participants = models.ManyToManyField(
		to=get_user_model(),
		related_name='participant_channels',
	)
	image = models.ImageField(
		upload_to='channels/image',
		default='default-channel-image.svg'
	)
	name = models.CharField(
		max_length=255,
		null=False,
	)
	description = models.TextField(
		blank=True,
	)
	visits_count = models.PositiveIntegerField(
		default=0,
	)
	
	def __str__(
		self,
	) -> str:
		return self.name
	
	def increment_visits(self):
		self.visits_count += 1
		self.save()
	
	def get_absolute_url(
		self
	):
		return reverse(
			viewname='channels:detail',
			kwargs={
				'pk': self.id,
			},
		)
	
	class Meta:
		verbose_name = 'Канал'
		verbose_name_plural = 'Каналы'



# class ChannelLink(models.Model):
# 	channel = models.ForeignKey(
# 		to=Channel,
# 		on_delete=models.CASCADE,
# 		related_name="channels_links",
# 	)
# 	url = models.URLField(
# 		max_length=2000,
# 	)
# 	text = models.CharField(
# 		max_length=255,
# 	)
#
# 	def __str__(self):
# 		return self.url
#
# 	class Meta:
# 		verbose_name = 'Ссылка канала'
# 		verbose_name_plural = 'Ссылки каналов'


-------------------- File: .\channels\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\channels\urls.py --------------------
from django.urls import path

from . import views

app_name = 'channels'

urlpatterns = [
	path(
		route='',
		view=views.SearchChannels.as_view(),
		name='search',
	),
	path(
		route='create',
		view=views.CreateChannel.as_view(),
		name='create',
	),
	path(
		route='of-user',
		view=views.UserChannels.as_view(),
		name='of-user',
	),
	path(
		route='<int:pk>',
		view=views.ChannelDetail.as_view(),
		name='detail',
	),
	path(
		route='<int:channel_id>/posts',
		view=views.ChannelPosts.as_view(),
		name='post-list',
	),
	path(
		route='<int:channel_id>/quizes',
		view=views.ChannelQuizes.as_view(),
		name='quizes',
	),
	path(
		route='<int:channel_id>/questions',
		view=views.ChannelQuestions.as_view(),
		name='questions',
	),
	path(
		route='<int:channel_id>/update',
		view=views.UpdateChannel.as_view(),
		name='update',
	),
	path(
		route='<int:channel_id>/subscribe',
		view=views.Subscribe.as_view(),
		name='subscribe',
	),
	path(
		route='<int:channel_id>/unsubscribe',
		view=views.Unsubscribe.as_view(),
		name='unsubscribe',
	),
	path(
		route='<int:channel_id>/control',
		view=views.ChannelControl.as_view(),
		name='control',
	),
	path(
		route='<int:channel_id>/delete',
		view=views.ChannelDeleteView.as_view(),
		name='delete',
	),
	path(
		route='<int:channel_id>/members',
		view=views.ChannelMembers.as_view(),
		name='members',
	),
	path(
		route='about',
		view=views.About.as_view(),
		name='about',
	),
]


-------------------- File: .\channels\views.py --------------------
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.paginator import Paginator
from django.http import (
	HttpRequest,
	HttpResponse,
)
from django.shortcuts import (
	get_object_or_404,
	redirect,
	render,
)
from django.urls import (
	reverse,
	reverse_lazy,
)
from django.views import View
from django.views.generic import (
	CreateView,
	DeleteView,
	DetailView,
	ListView,
	TemplateView,
	UpdateView,
)

from channels.forms import ChannelForm
from channels.mixins import (
	ChannelCreatorRequired2Mixin,
	ChannelMembershipRequiredMixin,
	ChannelParticipantRequiredMixin,
	ChannelCreatorRequiredMixin,
)
from channels.models import Channel

app_name = 'channels'


class ChannelPosts(
	LoginRequiredMixin,
	ChannelMembershipRequiredMixin,
	View,
):
	template_name = 'channels/post-list.html'
	
	def get(
		self,
		request,
		channel_id
	):
		channel = get_object_or_404(
			klass=Channel,
			pk=channel_id,
		)
		post_list = channel.posts.all()
		paginator = Paginator(
			object_list=post_list,
			per_page=10,
		)
		page_number = request.GET.get(
			'page'
		)
		page_obj = paginator.get_page(
			page_number
		)
		context = {
			'channel': channel,
			'page_obj': page_obj,
		}
		return render(
			request=request,
			template_name=self.template_name,
			context=context,
		)


class SearchChannels(
	ListView,
):
	model = Channel
	template_name = 'channels/search.html'
	context_object_name = 'channel_list'
	paginate_by = 10
	
	def get_queryset(
		self
	):
		return (
			Channel.popular
			.popular_channels()
			.filter(
				name__icontains=self.request.GET.get(
					'q',
					'',
				),
			)
		)
	
	def get_context_data(
		self,
		*,
		object_list=...,
		**kwargs
	):
		context = super().get_context_data(
			**kwargs
		)
		context['q'] = self.request.GET.get(
			'q'
		)
		return context


class ChannelDetail(
	DetailView,
):
	model = Channel
	template_name = 'channels/detail.html'
	
	def get_object(
		self,
		queryset=None
		):
		channel = super().get_object(
			queryset
		)
		channel.increment_visits()
		return channel


class CreateChannel(
	LoginRequiredMixin,
	CreateView,
):
	model = Channel
	form_class = ChannelForm
	template_name = 'channels/create.html'
	extra_context = {
		'form_title': 'Создание канала',
		'submit_button_inner': 'Создать',
	}
	
	def form_valid(
		self,
		form
	):
		form.instance.created_by = self.request.user
		return super().form_valid(
			form
		)
	
	def get_success_url(
		self
	):
		print(
			self.object.pk
		)
		return reverse(
			viewname='channels:detail',
			kwargs={
				'pk': self.object.pk,
			},
		)


class UpdateChannel(
	LoginRequiredMixin,
	ChannelCreatorRequiredMixin,
	UpdateView,
):
	model = Channel
	form_class = ChannelForm
	template_name = 'channels/update.html'
	extra_context = {
		'form_title': 'Редактирование канала',
		'submit_button_inner': 'Сохранить',
	}
	
	def get_success_url(
		self
	):
		return reverse(
			viewname='channels:detail',
			kwargs={
				'pk': self.object.pk,
			},
		)
	
	def get_object(
		self,
		queryset=...
		):
		channel_id = self.kwargs.get(
			'channel_id'
		)
		return get_object_or_404(
			klass=Channel,
			pk=channel_id,
		)


class UserChannels(
	LoginRequiredMixin,
	TemplateView,
):
	template_name = 'channels/of-user.html'


class Subscribe(
	LoginRequiredMixin,
	View,
):
	def post(
		self,
		request: HttpRequest,
		channel_id: int,
	) -> HttpResponse:
		channel = get_object_or_404(
			klass=Channel,
			pk=channel_id,
		)
		
		channel.participants.add(
			request.user
		)
		
		return redirect(
			to='channels:detail',
			pk=channel.pk,
		)


class Unsubscribe(
	LoginRequiredMixin,
	ChannelParticipantRequiredMixin,
	View,
):
	def post(
		self,
		request: HttpRequest,
		channel_id: int,
	) -> HttpResponse:
		channel = get_object_or_404(
			klass=Channel,
			pk=channel_id,
		)
		
		channel.participants.remove(
			request.user
		)
		
		return redirect(
			to='channels:detail',
			pk=channel.pk,
		)


class ChannelControl(
	LoginRequiredMixin,
	ChannelCreatorRequired2Mixin,
	View,
):
	template_name = 'channels/control.html'
	
	def get(
		self,
		request: HttpRequest,
		channel_id: int,
	) -> HttpResponse:
		channel = get_object_or_404(
			klass=Channel,
			pk=channel_id,
		)
		context = {
			'channel': channel,
		}
		
		return render(
			request=request,
			template_name=self.template_name,
			context=context,
		)

class ChannelDeleteView(
	LoginRequiredMixin,
	ChannelCreatorRequiredMixin,
	DeleteView,
):
	model = Channel
	template_name = 'channels/delete.html'
	success_url = reverse_lazy(
		'channels:of-user'
	)
	
	def get_object(
		self,
		queryset=None
		):
		# Получаем channel_id из URL
		channel_id = self.kwargs.get(
			'channel_id'
		)
		# Получаем объект канала по channel_id
		return get_object_or_404(
			Channel,
			pk=channel_id
		)


class ChannelMembers(
	LoginRequiredMixin,
	ChannelMembershipRequiredMixin,
	TemplateView,
):
	template_name = 'channels/members.html'
	
	def get_context_data(
		self,
		**kwargs
		):
		context = super().get_context_data(
			**kwargs
		)
		
		context['channel'] = Channel.objects.get(
			pk=self.kwargs['channel_id']
		)
		
		return context
	
class About(
	TemplateView,
):
	template_name = 'channels/about.html'


class ChannelQuizes(
	View,
):
	template_name = 'channels/quizes.html'
	def get(
		self,
		request: HttpRequest,
		channel_id: int,
	) -> HttpResponse:
		channel = get_object_or_404(
			klass=Channel,
			id=channel_id,
		)
		post_list = channel.quizes.all()
		paginator = Paginator(
			object_list=post_list,
			per_page=10,
		)
		page_number = request.GET.get(
			'page'
		)
		page_obj = paginator.get_page(
			page_number
		)
		context = {
			'channel': channel,
			'page_obj': page_obj,
		}
		return render(
			request=request,
			template_name=self.template_name,
			context=context,
		)


class ChannelQuestions(
	View,
):
	template_name = 'channels/questions.html'
	def get(
		self,
		request: HttpRequest,
		channel_id: int,
	) -> HttpResponse:
		channel = get_object_or_404(
			klass=Channel,
			id=channel_id,
		)
		questions = channel.questions.all()
		paginator = Paginator(
			object_list=questions,
			per_page=10,
		)
		page_number = request.GET.get(
			'page'
		)
		page_obj = paginator.get_page(
			page_number
		)
		context = {
			'channel': channel,
			'page_obj': page_obj,
		}
		return render(
			request=request,
			template_name=self.template_name,
			context=context,
		)


-------------------- File: .\channels\__init__.py --------------------


-------------------- File: .\channels\migrations\0001_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:55

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Channel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('image', models.ImageField(default='default-channel-image.svg', upload_to='channels/image')),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True)),
                ('visits_count', models.PositiveIntegerField(default=0)),
                ('created_by', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='created_channels', to=settings.AUTH_USER_MODEL)),
                ('participants', models.ManyToManyField(related_name='participant_channels', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Канал',
                'verbose_name_plural': 'Каналы',
            },
        ),
    ]


-------------------- File: .\channels\migrations\__init__.py --------------------


-------------------- File: .\channels\templatetags\channels_tags.py --------------------
from django import template

register = template.Library()


@register.inclusion_tag(
	filename='channels/card.html'
)
def show_channel_card(
	channel,
	user,
):
	return {
		'channel': channel,
		'user': user,
	}


-------------------- File: .\channels\templatetags\__init__.py --------------------


-------------------- File: .\posts\admin.py --------------------
from django.contrib import admin
from polymorphic.admin import (
	PolymorphicChildModelAdmin,
	PolymorphicParentModelAdmin,
)

from posts.models import (
	AssignmentPost,
	LearningMaterialPost,
	Post,
)


@admin.register(Post)
class PostAdmin(
	PolymorphicParentModelAdmin,
):
	base_model = Post
	child_models = (
		LearningMaterialPost,
		AssignmentPost,
	)


@admin.register(LearningMaterialPost)
class LearningMaterialPostAdmin(
	PolymorphicChildModelAdmin,
):
	base_model = Post


@admin.register(AssignmentPost)
class AssignmentPostAdmin(
	PolymorphicChildModelAdmin,
):
	base_model = Post


-------------------- File: .\posts\apps.py --------------------
from django.apps import AppConfig


class PostsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'posts'


-------------------- File: .\posts\forms.py --------------------
import bleach
from django import forms

from posts.models import (
	AssignmentPost,
	LearningMaterialPost,
	Post,
)
from tests_tests.models import Test


# from tasks.models import Task


class PostForm(
	forms.ModelForm,
):
	class Meta:
		model = Post
		fields = [
			'title',
			'content',
		]
		
	title = forms.CharField(
		label='Заголовок',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	content = forms.CharField(
		label="Содержимое (разрешённые теги: p, b, i, u, strong, ul, ol, li, br, code",
		widget=forms.Textarea(
			attrs={
				'class': 'form-control',
			},
		),
	)
	
	def clean_content(
		self
	):
		return bleach.clean(
			text=self.cleaned_data.get(
				'content'
			),
			tags=['p', 'b', 'i', 'u', 'strong', 'ul', 'ol', 'li', 'br', 'code'],
		)
	
	def save(self, commit=True):
		post = super().save(commit=False)
		if commit:
			post.save()  # Сохраняем пост, чтобы получить его ID
	
	# 	# Удаляем старые файлы
	#
	# 	AttachedFile.objects.filter(post=post).delete()
	#
	# 	# Сохраняем новые файлы
	# 	files = self.cleaned_data.get('files')
	# 	if files:
	# 		for file in files:
	# 			AttachedFile.objects.create(
	# 				post=post,
	# 				file=file,
	# 			)
	#
	# 	return post

class LearningMaterialPostForm(
	PostForm,
):
	class Meta(
		PostForm.Meta,
	):
		model = LearningMaterialPost
		fields = [
			'title',
			'content',
			'file',
		]

class AssignmentPostForm(
	PostForm,
):
	test = forms.ModelChoiceField(
		queryset=Test.objects.none(),
		required=False,
		label='Прикрепить тест (в разработке)',
		widget=forms.Select(
			attrs={
				'disabled': 'disabled',
			}
		)
	)
	# quiz = forms.ModelChoiceField(
	# 	queryset=Quiz.objects.all(),  # Изначально пустой queryset
	# 	required=False,  # Сделать необязательным, если не требуется
	# 	label='Выберите тест'
	# )
	
	class Meta(
		PostForm.Meta,
	):
		model = AssignmentPost
		fields = [
			'title',
			'content',
			# 'quiz',
			# 'task',
		]
		
	# def __init__(
	# 	self,
	# 	*args,
	# 	user=None,
	# 	channel=None,
	# 	**kwargs
	# ):
	# 	super().__init__(*args, **kwargs)
	# 	if user and channel:
	# 		self.fields['quiz'].queryset = Quiz.objects.filter(
	# 			created_by=user,
	# 			channel=channel,
	# 		)
	# 	else:
	# 		self.fields['quiz'].queryset = Quiz.objects.none()


-------------------- File: .\posts\mixins.py --------------------
from django.core.exceptions import PermissionDenied
from django.http import HttpResponseForbidden
from django.shortcuts import (
	get_object_or_404,
	render,
)

from channels.models import Channel
from posts.models import Post

class PostOwnershipOrAuthorMixin:
	"""
	Миксин для проверки, что пользователь является создателем или автором канала.
	"""
	def dispatch(self, request, *args, **kwargs):
		channel = Channel.objects.get(pk=self.kwargs['channel_id'])
		
		# Проверяем, является ли пользователь создателем или автором канала
		if request.user != channel.created_by:
			return HttpResponseForbidden('У вас нет прав на добавление постов в этот канал')
		
		return super().dispatch(request, *args, **kwargs)


class PostMembershipRequiredMixin:
	def dispatch(self, request, *args, **kwargs):
		channel = Post.objects.get(pk=self.kwargs['post_id']).channel
		
		# Проверяем, является ли пользователь создателем или автором канала
		if request.user != channel.created_by and request.user not in channel.participants.all():
			return HttpResponseForbidden('Вы не можете просматривать посты в этом канале')
		
		return super().dispatch(request, *args, **kwargs)
	

class PostUpdateMixin:
	def dispatch(self, request, *args, **kwargs):
		# Получаем канал по ID, который передается в URL
		channel = Post.objects.get(pk=self.kwargs['pk']).channel
		
		# Проверяем, является ли пользователь создателем или автором канала
		if request.user != channel.created_by and request.user not in channel.authors.all():
			return HttpResponseForbidden('Вы не можете редактировать посты в этом канале')
		
		return super().dispatch(request, *args, **kwargs)


class PostDeleteMixin:
	def dispatch(self, request, *args, **kwargs):
		# Получаем канал по ID, который передается в URL
		channel = Post.objects.get(pk=self.kwargs['pk']).channel
		
		# Проверяем, является ли пользователь создателем или автором канала
		if request.user != channel.created_by and request.user not in channel.authors.all():
			return HttpResponseForbidden('Вы не можете удалять посты в этом канале')
		
		return super().dispatch(request, *args, **kwargs)


-------------------- File: .\posts\models.py --------------------
from django.contrib.auth import get_user_model
from django.db import models
from django.urls import reverse
from django.utils.timezone import now
from polymorphic.models import PolymorphicModel

from channels.models import (
	Channel,
)

# from tasks.models import Task


class Post(
	PolymorphicModel,
):
	channel = models.ForeignKey(
		to=Channel,
		on_delete=models.CASCADE,
		related_name='posts',
	)
	title = models.CharField(
		max_length=255,
	)
	content = models.TextField(
		blank=True,
		null=True,
	)
	created_at = models.DateTimeField(
		auto_now_add=True,
	)
	updated_at = models.DateTimeField(
		auto_now=True,
	)
	
	# METHODS
	
	def __str__(
		self
	):
		real_instance = self.get_real_instance()
		return (
			f'{real_instance.__class__.__name__}: '
			f'{self.title}'
		)
	
	def get_absolute_url(
		self
	):
		return reverse(
			viewname='posts:detail',
			kwargs={
				'post_id': self.pk,
			}
		)
	
	class Meta:
		ordering = ['-created_at']
		verbose_name = 'Пост'
		verbose_name_plural = 'Посты'


class LearningMaterialPost(
	Post,
):
	file = models.FileField(
		upload_to="posts/files/%Y/%m/%d/",
		verbose_name="Файл",
		null=True,
		blank=True,
	)


class AssignmentPost(
	Post,
):
	test = models.OneToOneField(
		to='tests_tests.Test',
		on_delete=models.SET_NULL,
		null=True,
		related_name='post',
	)


-------------------- File: .\posts\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\posts\urls.py --------------------
from django.urls import path

from . import views

app_name = 'posts'

urlpatterns = [
	path(
		route='<int:post_id>',
		view=views.ShowPost.as_view(),
		name='detail',
	),
	path(
		route='create/assignment/<int:channel_id>',
		view=views.CreateAssignmentPost.as_view(),
		name='create-assignment',
	),
	path(
		route='create/material/<int:channel_id>',
		view=views.CreateLearningMaterialPost.as_view(),
		name='create-material',
	),
	path(
		route='<int:pk>/update-assignment',
		view=views.UpdateAssignmentPost.as_view(),
		name='update-assignment',
	),
	path(
		route='<int:pk>/update-learning',
		view=views.UpdateLearningMaterialPost.as_view(),
		name='update-learning',
	),
	path(
		route='<int:pk>/delete',
		view=views.PostDeleteView.as_view(),
		name='delete',
	),
]


-------------------- File: .\posts\views.py --------------------
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import (
	HttpRequest,
	HttpResponse,
)
from django.shortcuts import (
	get_object_or_404,
	render,
)
from django.urls import (
	reverse,
	reverse_lazy,
)
from django.views import View
from django.views.generic import (
	CreateView,
	DeleteView,
	UpdateView,
)


from channels.models import Channel

from . import mixins as posts_mixins
from .forms import (
	AssignmentPostForm,
	LearningMaterialPostForm,
	PostForm,
)
from .models import (
	AssignmentPost,
	LearningMaterialPost,
	Post,
)


class ShowPost(
	LoginRequiredMixin,
	posts_mixins.PostMembershipRequiredMixin,
	View,
):
	template_name = 'posts/detail.html'
	
	def get(
		self,
		request: HttpRequest,
		post_id: int,
	) -> HttpResponse:
		post = get_object_or_404(
			klass=Post,
			pk=post_id,
		)
		context = {
			'post': post,
		}
		return render(
			request=request,
			template_name=self.template_name,
			context=context,
		)
	

class CreatePost(
	LoginRequiredMixin,
	posts_mixins.PostOwnershipOrAuthorMixin,
	CreateView,
):
	model = Post
	form_class = PostForm
	template_name = 'posts/create.html'

	def form_valid(self, form):
		channel = get_object_or_404(
			klass=Channel,
			id=self.kwargs['channel_id'],
		)
		
		# Устанавливаем канал для нового поста
		form.instance.channel = channel
		
		return super().form_valid(form)
	
	def get_success_url(self):
		# Перенаправление после успешного создания поста
		return reverse_lazy('channels:post-list', kwargs={'channel_id': self.object.channel.id})
	
	
# class UpdatePost(
# 	LoginRequiredMixin,
# 	posts_mixins.PostUpdateMixin,
# 	UpdateView,
# ):
# 	model = Post
# 	form_class = PostForm
# 	template_name = 'app/form.html'
# 	extra_context = {
# 		'form_title': 'Изменение поста',
# 		'submit_button_inner': 'Сохранить изменения',
# 	}
#
# 	def get_success_url(self):
# 		return reverse_lazy('posts:detail', kwargs={'post_id': self.object.id})


class PostDeleteView(
	LoginRequiredMixin,
	posts_mixins.PostDeleteMixin,
	DeleteView,
):
	model = Post
	template_name = 'posts/delete.html'
	context_object_name = 'post'
	
	def get_success_url(self):
	# Возвращаем URL для списка постов данного канала
		return reverse_lazy('channels:post-list', kwargs={'channel_id': self.object.channel.id})


class CreateLearningMaterialPost(
	CreateView,
):
	template_name = 'app/form.html'
	model = LearningMaterialPost
	form_class = LearningMaterialPostForm
	extra_context = {
		'form_title': 'Добавление учебного материала',
		'submit_button_inner': 'Создать',
	}
	
	def form_valid(self, form):
		channel_id = self.kwargs['channel_id']
		form.instance.channel_id = channel_id
		response = super().form_valid(form)
		return response
	
	def get_success_url(self):
		channel_id = self.kwargs['channel_id']
		return reverse(
			viewname='channels:post-list',
			kwargs={
				'channel_id': channel_id
			},
		)


class CreateAssignmentPost(
	CreateView,
):
	template_name = 'app/form.html'
	model = AssignmentPost
	form_class = AssignmentPostForm
	extra_context = {
		'form_title': 'Добавление теста',
		'submit_button_inner': 'Создать',
	}
	
	def form_valid(self, form):
		channel_id = self.kwargs['channel_id']
		form.instance.channel_id = channel_id
		response = super().form_valid(form)
		return response
	
	def get_success_url(self):
		channel_id = self.kwargs['channel_id']
		return reverse(
			viewname='channels:post-list',
			kwargs={
				'channel_id': channel_id
			},
		)


class UpdateAssignmentPost(
	UpdateView,
):
	template_name = 'app/form.html'
	model = AssignmentPost
	form_class = AssignmentPostForm
	extra_context = {
		'form_title': 'Обновление поста',
		'submit_button_inner': 'Обновить',
	}
	
	def get_success_url(self):
		post_id = self.kwargs['pk']
		return reverse(
			viewname='posts:detail',
			kwargs={
				'post_id': post_id
			},
		)


class UpdateLearningMaterialPost(
	UpdateView,
):
	template_name = 'app/form.html'
	model = LearningMaterialPost
	form_class = LearningMaterialPostForm
	extra_context = {
		'form_title': 'Обновление поста',
		'submit_button_inner': 'Обновить',
	}
	
	def get_success_url(self):
		post_id = self.kwargs['pk']
		return reverse(
			viewname='posts:detail',
			kwargs={
				'post_id': post_id
			},
		)


-------------------- File: .\posts\__init__.py --------------------


-------------------- File: .\posts\migrations\0001_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 13:00

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('channels', '0001_initial'),
        ('contenttypes', '0002_remove_content_type_name'),
        ('tests_tests', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Post',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
                ('content', models.TextField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('channel', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='posts', to='channels.channel')),
                ('polymorphic_ctype', models.ForeignKey(editable=False, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='polymorphic_%(app_label)s.%(class)s_set+', to='contenttypes.contenttype')),
            ],
            options={
                'verbose_name': 'Пост',
                'verbose_name_plural': 'Посты',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='LearningMaterialPost',
            fields=[
                ('post_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='posts.post')),
                ('file', models.FileField(blank=True, null=True, upload_to='posts/files/%Y/%m/%d/', verbose_name='Файл')),
            ],
            options={
                'abstract': False,
                'base_manager_name': 'objects',
            },
            bases=('posts.post',),
        ),
        migrations.CreateModel(
            name='AssignmentPost',
            fields=[
                ('post_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='posts.post')),
                ('test', models.OneToOneField(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='post', to='tests_tests.test')),
            ],
            options={
                'abstract': False,
                'base_manager_name': 'objects',
            },
            bases=('posts.post',),
        ),
    ]


-------------------- File: .\posts\migrations\__init__.py --------------------


-------------------- File: .\posts\templatetags\posts_tags.py --------------------
from django import template

register = template.Library()


@register.inclusion_tag(
	filename='posts/card.html'
)
def show_post_card(
	post,
):
	return {
		'post': post,
	}


@register.inclusion_tag(
	filename='posts/comment.html',
)
def show_comment(
	comment,
	user,
):
	return {
		'comment': comment,
		'user': user,
	}


@register.inclusion_tag(
	filename='posts/icon.html',
)
def show_post_icon(
	post,
	icon_width,
):
	return {
		'post': post,
		'icon_width': icon_width,
	}


-------------------- File: .\posts\templatetags\__init__.py --------------------


-------------------- File: .\scia\admin.py --------------------
from django.contrib import admin

# Register your models here.


-------------------- File: .\scia\apps.py --------------------
from django.apps import AppConfig


class SciaConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'scia'


-------------------- File: .\scia\models.py --------------------
from django.db import models

# Create your models here.


-------------------- File: .\scia\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\scia\urls.py --------------------
from django.urls import (
	path,
)

from scia.views import (
	CookieView,
	DeleteCookieView,
	SessionView,
)

app_name = 'scia'

urlpatterns = [
	path('cookie/', CookieView.as_view(), name='cookie_view'),
	path('session/', SessionView.as_view(), name='session_view'),
	path('cookie/delete/', DeleteCookieView.as_view(), name='delete_cookie_view'),
]


-------------------- File: .\scia\views.py --------------------
import json

from django.http import JsonResponse
from django.views import View
from django.shortcuts import render
from django.middleware.csrf import get_token

class CookieView(View):
	"""
	Класс для работы с куки.
	"""

	def get(self, request):
		if request.headers.get('X-Requested-With') == 'XMLHttpRequest':  # Проверка AJAX-запроса
			cookie_value = request.COOKIES.get('example_cookie', 'Куки отсутствуют')
			return JsonResponse({'cookie_value': cookie_value})
		return render(request, 'cookie.html')

	def post(self, request):
		try:
			data = json.loads(request.body)  # Чтение данных из JSON
			cookie_value = data.get('cookie_value', 'Значение по умолчанию')
			response = JsonResponse({'message': 'Куки успешно установлены'})
			response.set_cookie(
				key='example_cookie',
				value=cookie_value,
				max_age=3600,
				httponly=True
			)
			return response
		except json.JSONDecodeError:
			return JsonResponse({'message': 'Неверный формат данных'}, status=400)
	
	def delete(self, request):
		# Удаление куки
		response = JsonResponse({'message': 'Куки удалены'})
		response.delete_cookie('example_cookie')
		return response

class DeleteCookieView(View):
	def post(self, request):
		response = JsonResponse({'message': 'Куки успешно удалены'})
		response.delete_cookie('example_cookie')
		return response


class SessionView(View):
	def post(self, request):
		try:
			data = json.loads(request.body)  # Чтение данных из JSON
			session_value = data.get('session_value', 'Значение по умолчанию')
			request.session['example_session'] = session_value
			return JsonResponse({'message': 'Сессия успешно установлена'})
		except json.JSONDecodeError:
			return JsonResponse({'message': 'Неверный формат данных'}, status=400)
	
	def get(self, request):
		if request.headers.get('X-Requested-With') == 'XMLHttpRequest':  # Проверка AJAX-запроса
			session_value = request.session.get('example_session', 'Сессия не установлена')
			return JsonResponse({'session_value': session_value})
		return render(request, 'session.html')
	
	def delete(self, request):
		try:
			del request.session['example_session']
			return JsonResponse({'message': 'Сессия успешно удалена'})
		except KeyError:
			return JsonResponse({'message': 'Сессия не найдена'}, status=404)


-------------------- File: .\scia\__init__.py --------------------


-------------------- File: .\skillthread\asgi.py --------------------
import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', '_.settings')

application = get_asgi_application()


-------------------- File: .\skillthread\settings.py --------------------
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(
	__file__
	).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-g&trgb5_5g(7+dxwf%=wyz581o6r$ee%$%&b4+n+%_f@@&5i1$'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['127.0.0.1']

# Application definition

INSTALLED_APPS = [
	'django.contrib.admin',
	'django.contrib.auth',
	'django.contrib.sessions',
	'django.contrib.messages',
	'django.contrib.staticfiles',
	'django_extensions',
	'polymorphic',
	'django.contrib.contenttypes',
	'app',
	'users',
	'channels',
	'posts',
	'scia',
	'tests_tests',
	'tests_questions',
	'tests_answers',
]

MIDDLEWARE = [
	'django.middleware.security.SecurityMiddleware',
	'django.contrib.sessions.middleware.SessionMiddleware',
	'django.middleware.common.CommonMiddleware',
	'django.middleware.csrf.CsrfViewMiddleware',
	'django.contrib.auth.middleware.AuthenticationMiddleware',
	'django.contrib.messages.middleware.MessageMiddleware',
	'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'skillthread.urls'

TEMPLATES = [
	{
		'BACKEND': 'django.template.backends.django.DjangoTemplates',
		'DIRS': [
			BASE_DIR / 'templates',
		],
		'APP_DIRS': True,
		'OPTIONS': {
			'context_processors': [
				'django.template.context_processors.debug',
				'django.template.context_processors.request',
				'django.contrib.auth.context_processors.auth',
				'django.contrib.messages.context_processors.messages',
			],
		},
	},
]

WSGI_APPLICATION = 'skillthread.wsgi.application'

# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
	'default': {
		'ENGINE': 'django.db.backends.mysql',
		'NAME': 'skillthread',
		'USER': 'root',
		'PASSWORD': 'root',
		'HOST': 'localhost',
		'PORT': '3306',
	}
	# 'default': {
	# 	'ENGINE': 'django.db.backends.sqlite3',
	# 	'NAME': 'db.sqlite3',
	# }
}

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
	{
		'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
	},
	{
		'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
	},
	{
		'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
	},
	{
		'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
	},
]

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'ru'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = '/static/'
STATICFILES_DIRS = [
	BASE_DIR / 'static',
]
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# other

LOGIN_REDIRECT_URL = 'channels:search'
LOGOUT_REDIRECT_URL = 'index'
LOGIN_URL = 'users:login'

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media/'

AUTH_USER_MODEL = 'users.User'


-------------------- File: .\skillthread\urls.py --------------------
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import (
	path,
	include,
)

from . import settings

urlpatterns = [
	path(
		route='admin/',
		view=admin.site.urls,
	),
	
	path(
		route='',
		view=include(
			arg='app.urls',
		),
	),
	path(
		route='users/',
		view=include(
			arg='users.urls',
			namespace='users',
		),
	),
	path(
		route='channels/',
		view=include(
			arg='channels.urls',
			namespace='channels',
		),
	),
	path(
		route='posts/',
		view=include(
			arg='posts.urls',
			namespace='posts',
		),
	),
	path(
		route='tests/',
		view=include(
			arg='tests_tests.urls',
			namespace='tests',
		),
	),
	path(
		route='',
		view=include(
			arg='scia.urls',
		),
	),
]

if settings.DEBUG:
	urlpatterns += static(
		settings.MEDIA_URL,
		document_root=settings.MEDIA_ROOT
	)


-------------------- File: .\skillthread\wsgi.py --------------------
import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', '_.settings')

application = get_wsgi_application()


-------------------- File: .\skillthread\__init__.py --------------------


-------------------- File: .\tests_answers\admin.py --------------------
from django.contrib import admin

# Register your models here.


-------------------- File: .\tests_answers\apps.py --------------------
from django.apps import AppConfig


class TestsAnswersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'tests_answers'


-------------------- File: .\tests_answers\forms.py --------------------
from django import forms

from tests_answers.models import Answer


class AnswerForm(forms.ModelForm):
	class Meta:
		model = Answer
		fields = ['text', 'is_correct']


-------------------- File: .\tests_answers\formsets.py --------------------
from django.forms import (
	inlineformset_factory,
	modelformset_factory,
)

from tests_answers.forms import AnswerForm
from tests_answers.models import Answer
from tests_questions.models import Question

AnswerFormSet = inlineformset_factory(
	parent_model=Question,
	model=Answer,
	form=AnswerForm,
	extra=2,  # Количество пустых форм для новых ответов
	can_delete=True,
)


-------------------- File: .\tests_answers\models.py --------------------
from django.db import models


class Answer(
	models.Model
):
	question = models.ForeignKey(
		to='tests_questions.Question',
		related_name='answers',
		on_delete=models.CASCADE,
	)
	text = models.CharField(
		max_length=255,
	)
	is_correct = models.BooleanField(
		default=False,
	)

class AnswerResponse(
	models.Model
):
	test_attempt = models.ForeignKey(
		to='tests_tests.TestAttempt',
		related_name='responses',
		on_delete=models.CASCADE,
	)
	question = models.ForeignKey(
		to='tests_questions.Question',
		on_delete=models.CASCADE,
	)
	selected_answer = models.ForeignKey(
		to='tests_answers.Answer',
		null=True,
		blank=True,
		on_delete=models.SET_NULL,
	)
	
	class Meta:
		unique_together = ('test_attempt', 'question')

class AnswerOrder(models.Model):
	test_attempt = models.ForeignKey(
		to='tests_tests.TestAttempt',
		related_name='answer_orders',
		on_delete=models.CASCADE
	)
	answer = models.ForeignKey(
		to='tests_answers.Answer',
		related_name='answer_orders',
		on_delete=models.CASCADE
	)
	order = models.IntegerField()  # Порядок выбранного ответа для данного пользователя
	
	class Meta:
		ordering = ['order']  # Порядок ответов по возрастанию order
		unique_together = ('test_attempt', 'answer')  # Уникальность по пользователю,
	# ответу и ответу пользователя


-------------------- File: .\tests_answers\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\tests_answers\views.py --------------------
from django.shortcuts import render

# Create your views here.


-------------------- File: .\tests_answers\__init__.py --------------------


-------------------- File: .\tests_answers\migrations\0001_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:58

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Answer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('text', models.CharField(max_length=255)),
                ('is_correct', models.BooleanField(default=False)),
            ],
        ),
        migrations.CreateModel(
            name='AnswerOrder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('order', models.IntegerField()),
            ],
            options={
                'ordering': ['order'],
            },
        ),
        migrations.CreateModel(
            name='AnswerResponse',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
            ],
        ),
    ]


-------------------- File: .\tests_answers\migrations\0002_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:58

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('tests_answers', '0001_initial'),
        ('tests_questions', '0001_initial'),
        ('tests_tests', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='answer',
            name='question',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='answers', to='tests_questions.question'),
        ),
        migrations.AddField(
            model_name='answerorder',
            name='answer',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='answer_orders', to='tests_answers.answer'),
        ),
        migrations.AddField(
            model_name='answerorder',
            name='test_attempt',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='answer_orders', to='tests_tests.testattempt'),
        ),
        migrations.AddField(
            model_name='answerresponse',
            name='question',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='tests_questions.question'),
        ),
        migrations.AddField(
            model_name='answerresponse',
            name='selected_answer',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='tests_answers.answer'),
        ),
        migrations.AddField(
            model_name='answerresponse',
            name='test_attempt',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='responses', to='tests_tests.testattempt'),
        ),
        migrations.AlterUniqueTogether(
            name='answerorder',
            unique_together={('test_attempt', 'answer')},
        ),
        migrations.AlterUniqueTogether(
            name='answerresponse',
            unique_together={('test_attempt', 'question')},
        ),
    ]


-------------------- File: .\tests_answers\migrations\__init__.py --------------------


-------------------- File: .\tests_questions\admin.py --------------------
from django.contrib import admin

# Register your models here.


-------------------- File: .\tests_questions\apps.py --------------------
from django.apps import AppConfig


class TestsQuestionsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'tests_questions'


-------------------- File: .\tests_questions\forms.py --------------------
from django import forms

from tests_questions.models import Question


class QuestionForm(forms.ModelForm):
	class Meta:
		model = Question
		fields = ['text']


-------------------- File: .\tests_questions\formsets.py --------------------
from django.forms import (
	inlineformset_factory,
	modelformset_factory,
)

from tests_answers.formsets import AnswerFormSet
from tests_questions.forms import QuestionForm
from tests_questions.models import Question

from django import forms

from tests_tests.models import Test


class BaseQuestionFormSet(forms.BaseInlineFormSet):
	def __init__(self, *args, **kwargs):
		self.nested_formsets = []
		super().__init__(*args, **kwargs)
		# Создание вложенных AnswerFormSet для каждого вопроса
		for question_form in self.forms:
			instance = question_form.instance
			question_form.nested_formset = AnswerFormSet(
				instance=instance,
				prefix=f"answers_{question_form.prefix}",
				data=kwargs.get('data') if question_form.is_bound else None,
				files=kwargs.get('files') if question_form.is_bound else None,
			)
			self.nested_formsets.append(question_form.nested_formset)
	
	def is_valid(self):
		if not super().is_valid():
			return False
		# Проверка валидности вложенных AnswerFormSet
		for nested_formset in self.nested_formsets:
			if not nested_formset.is_valid():
				return False
		return True
	
	def save(self, commit=True):
		# Сохраняем вопросы
		instances = super().save(commit=commit)
		for form, instance in zip(self.forms, instances):
			# Сохраняем ответы для каждого вопроса
			form.nested_formset.instance = instance
			form.nested_formset.save(commit=commit)
		return instances

QuestionFormSet = inlineformset_factory(
	parent_model=Test,
	model=Question,
	form=QuestionForm,
	formset=BaseQuestionFormSet,
	extra=1,
	can_delete=True,
)


-------------------- File: .\tests_questions\models.py --------------------
from django.db import models


class Question(
	models.Model
):
	test = models.ForeignKey(
		to='tests_tests.Test',
		related_name='questions',
		on_delete=models.CASCADE
	)
	text = models.CharField(
		max_length=255
	)


class QuestionOrder(
	models.Model
):
	test_attempt = models.ForeignKey(
		to='tests_tests.TestAttempt',
		related_name='question_orders',
		on_delete=models.CASCADE
	)
	question = models.ForeignKey(
		to='tests_questions.Question',
		related_name='question_orders',
		on_delete=models.CASCADE
	)
	order = models.IntegerField()
	
	class Meta:
		ordering = ['order']
		unique_together = ('test_attempt', 'question')


-------------------- File: .\tests_questions\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\tests_questions\urls.py --------------------
from django.urls import path

from . import views

app_name = 'channels'

urlpatterns = [
	path(
		route='create',
		view=views.TestCreateView.as_view(),
		name='create',
	),
]


-------------------- File: .\tests_questions\views.py --------------------


-------------------- File: .\tests_questions\__init__.py --------------------


-------------------- File: .\tests_questions\migrations\0001_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:58

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('text', models.CharField(max_length=255)),
            ],
        ),
        migrations.CreateModel(
            name='QuestionOrder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('order', models.IntegerField()),
            ],
            options={
                'ordering': ['order'],
            },
        ),
    ]


-------------------- File: .\tests_questions\migrations\0002_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:58

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('tests_questions', '0001_initial'),
        ('tests_tests', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='question',
            name='test',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='questions', to='tests_tests.test'),
        ),
        migrations.AddField(
            model_name='questionorder',
            name='question',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='question_orders', to='tests_questions.question'),
        ),
        migrations.AddField(
            model_name='questionorder',
            name='test_attempt',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='question_orders', to='tests_tests.testattempt'),
        ),
        migrations.AlterUniqueTogether(
            name='questionorder',
            unique_together={('test_attempt', 'question')},
        ),
    ]


-------------------- File: .\tests_questions\migrations\__init__.py --------------------


-------------------- File: .\tests_tests\admin.py --------------------
from django.contrib import admin

# @admin.register()


-------------------- File: .\tests_tests\apps.py --------------------
from django.apps import AppConfig


class TestsTestsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'tests_tests'


-------------------- File: .\tests_tests\forms.py --------------------
from django import forms
from django.forms import modelformset_factory

from tests_questions.forms import QuestionForm
from tests_questions.models import Question
from tests_tests.models import Test


class TestForm(
	forms.ModelForm
):
	class Meta:
		model = Test
		fields = ['title', 'description', 'duration']


-------------------- File: .\tests_tests\models.py --------------------
from django.contrib.auth import get_user_model
from django.db import models


class Test(
	models.Model
):
	title = models.CharField(
		max_length=255
	)
	description = models.TextField()
	duration = models.DurationField(
		null=True,
		blank=True,
	)
	created_at = models.DateTimeField(
		auto_now_add=True
	)
	updated_at = models.DateTimeField(
		auto_now=True
	)


class TestAttempt(
	models.Model
):
	user = models.ForeignKey(
		to=get_user_model(),
		related_name='test_attempts',
		on_delete=models.CASCADE
	)
	test = models.ForeignKey(
		to='tests_tests.Test',
		related_name='attempts',
		on_delete=models.CASCADE
	)
	started_at = models.DateTimeField(
		auto_now_add=True
	)
	completed_at = models.DateTimeField(
		null=True,
		blank=True
	)
	status = models.CharField(
		max_length=50,
		choices=[
			('in_progress', 'In Progress'),
			('completed', 'Completed'),
		],
	)
	score = models.FloatField(
		null=True,
		blank=True
	)
	current_question = models.ForeignKey(
		to='tests_questions.Question',
		related_name='current_attempts',
		null=True,
		blank=True,
		on_delete=models.SET_NULL
	)


class TestResult(
	models.Model
):
	test_attempt = models.ForeignKey(
		to='tests_tests.TestAttempt',
		on_delete=models.CASCADE
	)
	total_score = models.FloatField()
	passed = models.BooleanField(
		default=False
	)
	# feedback = models.TextField(
	# 	null=True,
	# 	blank=True
	# )


-------------------- File: .\tests_tests\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\tests_tests\urls.py --------------------
from django.urls import path

from . import views

app_name = 'tests_tests'

urlpatterns = [
	path(
		route='create',
		view=views.TestCreateView.as_view(),
		name='create',
	),
]


-------------------- File: .\tests_tests\views.py --------------------
from django.db import transaction
from django.forms import modelformset_factory
from django.http import HttpResponse
from django.shortcuts import (
	redirect,
	render,
)
from django.views import View
from django.views.generic import ListView

from tests_answers.forms import AnswerForm
from tests_answers.formsets import AnswerFormSet
from tests_answers.models import Answer
from tests_questions.forms import QuestionForm
from tests_questions.formsets import QuestionFormSet
from tests_questions.models import Question
from tests_tests.forms import TestForm
from tests_tests.models import Test


class TestCreateView(
	View
):
	def get(self, request):
		return render(
			request=request,
			template_name='tests_tests/create.html',
		)
	
	def post(self, request):
		print(request.POST)
		return HttpResponse(code=200)
# 	def get(self, request, *args, **kwargs):
# 		test_form = TestForm()
#
# 		# Формы для вопросов
# 		question_formset = QuestionFormSet(queryset=Question.objects.none())
#
# 		# Формы для ответов
# 		answer_formsets = [AnswerFormSet(queryset=Answer.objects.none(), prefix=f'answers_{i}') for i in range(question_formset.total_form_count())]
#
# 		return render(
# 			request,
# 			'tests_tests/create_test.html',
# 			{'test_form': test_form, 'question_formset': question_formset, 'answer_formsets': answer_formsets}
# 		)
#
# 	def post(self, request, *args, **kwargs):
# 		test_form = TestForm(request.POST)
#
# 		# Обработка вопросов
# 		question_formset = QuestionFormSet(request.POST)
#
# 		# Обработка ответов
# 		answer_formsets = [AnswerFormSet(request.POST, prefix=f'answers_{i}') for i in range(question_formset.total_form_count())]
#
# 		if test_form.is_valid() and question_formset.is_valid() and all(formset.is_valid() for formset in answer_formsets):
# 			# Начинаем транзакцию для атомарности
# 			with transaction.atomic():
# 				test = test_form.save()
#
# 				# Сохраняем вопросы
# 				for question_form in question_formset:
# 					question = question_form.save(commit=False)
# 					question.test = test
# 					question.save()
#
# 					# Сохраняем ответы для каждого вопроса
# 					for answer_form in answer_formsets[question_formset.forms.index(question_form)]:
# 						answer = answer_form.save(commit=False)
# 						answer.question = question
# 						answer.save()
#
# 				return redirect('tests_tests:test_detail', pk=test.pk)
#
# 		return render(
# 			request,
# 			'tests_tests/create_test.html',
# 			{'test_form': test_form, 'question_formset': question_formset, 'answer_formsets': answer_formsets}
# 		)
#
# def test(request):
# 	return render(request, 'test.html')


-------------------- File: .\tests_tests\__init__.py --------------------


-------------------- File: .\tests_tests\migrations\0001_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:58

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('tests_questions', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Test',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
                ('description', models.TextField()),
                ('duration', models.DurationField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='TestAttempt',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('started_at', models.DateTimeField(auto_now_add=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('status', models.CharField(choices=[('in_progress', 'In Progress'), ('completed', 'Completed')], max_length=50)),
                ('score', models.FloatField(blank=True, null=True)),
                ('current_question', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='current_attempts', to='tests_questions.question')),
                ('test', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='attempts', to='tests_tests.test')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='test_attempts', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='TestResult',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('total_score', models.FloatField()),
                ('passed', models.BooleanField(default=False)),
                ('test_attempt', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='tests_tests.testattempt')),
            ],
        ),
    ]


-------------------- File: .\tests_tests\migrations\__init__.py --------------------


-------------------- File: .\users\admin.py --------------------
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin

from users.models import User

# Register your models here.

admin.site.register(User, UserAdmin)


-------------------- File: .\users\apps.py --------------------
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users'


-------------------- File: .\users\forms.py --------------------
from crispy_forms.helper import FormHelper
from django import forms
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import (
	AuthenticationForm,
	PasswordChangeForm,
	SetPasswordMixin,
	UserChangeForm,
	UserCreationForm,
)
from django.forms import ModelForm
from django.urls import reverse_lazy


class LoginUserForm(
	AuthenticationForm,
):
	username = forms.CharField(
		label='Логин',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	password = forms.CharField(
		label='Пароль',
		widget=forms.PasswordInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	

class RegisterUserForm(
	UserCreationForm,
):
	username = forms.CharField(
		label='Логин',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	email = forms.EmailField(
		label='Электронная почта',
		widget=forms.EmailInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	first_name = forms.CharField(
		label='Имя',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	last_name = forms.CharField(
		label='Фамилия',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	password1 = forms.CharField(
		label='Пароль',
		widget=forms.PasswordInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	password2 = forms.CharField(
		label='Повтор пароля',
		widget=forms.PasswordInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	
	class Meta:
		model = get_user_model()
		fields = ['username', 'email', 'first_name', 'last_name', 'password1', 'password2']
	
	# def clean_repeat_password(self):
	# 	if self.cleaned_data['password'] != self.cleaned_data['repeat_password']:
	# 		raise forms.ValidationError('Пароли должны совпадать.')
	# 	return self.cleaned_data['repeat_password']
	#
	def clean_email(self):
		email = self.cleaned_data['email']
		if get_user_model().objects.filter(email=email).exists():
			raise forms.ValidationError(
				message='Такой электронный адрес уже используется',
			)
		return email
	
	
class CustomPasswordChangeForm(
	PasswordChangeForm,
):
	old_password = forms.CharField(
		label='Старый пароль',
		strip=False,
		widget=forms.PasswordInput(
			attrs={
				"autocomplete": "current-password",
				"autofocus": True,
				'class': 'form-control',
			}
		),
	)
	new_password1 = forms.CharField(
		label='Новый пароль',
		widget=forms.PasswordInput(
			attrs={
				'class': 'form-control',
			}
		),
	)
	new_password2 = forms.CharField(
		label='Подтверждение пароля',
		widget=forms.PasswordInput(
			attrs={
				'class': 'form-control',
			}
		),
	)
	
class UpdateUserForm(
	UserChangeForm,
):
	username = forms.CharField(
		label='Логин',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	email = forms.EmailField(
		label='Электронная почта',
		widget=forms.EmailInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	first_name = forms.CharField(
		label='Имя',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	last_name = forms.CharField(
		label='ф',
		widget=forms.TextInput(
			attrs={
				'class': 'form-control',
			},
		),
	)
	
	class Meta:
		model = get_user_model()
		fields = ['username', 'email', 'first_name', 'last_name']


-------------------- File: .\users\mixins.py --------------------
from django.http import HttpResponseForbidden


class UserIsOwnerMixin:
	"""
	Миксин для проверки, что пользователь пытается изменить только свой профиль.
	"""
	def dispatch(self, request, *args, **kwargs):
		if kwargs.get('pk') and int(kwargs['pk']) != request.user.pk:
			return HttpResponseForbidden("Вы не можете изменять чужой профиль.")
		return super().dispatch(request, *args, **kwargs)


-------------------- File: .\users\models.py --------------------
import os

from django.contrib.auth.models import AbstractUser
from django.db import models
from django.urls import reverse


def user_avatar_path(instance, filename):
	return os.path.join('avatars', str(instance.id))


class User(
	AbstractUser,
):
	photo = models.ImageField(
		upload_to=user_avatar_path,
		blank=True,
		null=True,
		verbose_name='Аватарка',
	)
	
	class Meta:
		verbose_name = 'Пользователь'
		verbose_name_plural = 'Пользователи'
		
	def get_absolute_url(self):
		return reverse(
			viewname='users:detail',
			kwargs={
				'pk': self.id,
			},
		)


-------------------- File: .\users\tests.py --------------------
from django.test import TestCase

# Create your tests here.


-------------------- File: .\users\urls.py --------------------
from django.contrib.auth.views import (
	LogoutView,
	PasswordChangeDoneView,
	PasswordChangeView,
)
from django.urls import path

from . import views

app_name = 'users'

urlpatterns = [
	path(
		route='login/',
		view=views.LoginUser.as_view(),
		name='login',
	),
	path(
		route='logout/',
		view=LogoutView.as_view(),
		name='logout',
	),
	path(
		route='register/',
		view=views.RegisterUser.as_view(),
		name='register',
	),
	path(
		route='<int:pk>',
		view=views.UserDetailView.as_view(),
		name='detail',
	),
	path(
		route='password-change',
		view=views.CustomPasswordChangeView.as_view(),
		name='password-change',
	),
	path(
		route='password-change-done',
		view=views.CustomPasswordChangeDoneView.as_view(),
		name='password-change-done',
	),
	path(
		route='<int:pk>/update',
		view=views.UserUpdateView.as_view(),
		name='update',
	),
]


-------------------- File: .\users\views.py --------------------
from django.contrib import messages
from django.contrib.auth import (
	authenticate,
	get_user_model,
	login,
	logout,
)
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.views import (
	LoginView,
	PasswordChangeDoneView,
	PasswordChangeView,
)
from django.http import (
	HttpRequest,
	HttpResponse,
	HttpResponseRedirect,
)
from django.shortcuts import render
from django.urls import (
	reverse,
	reverse_lazy,
)
from django.views import View
from django.views.generic import (
	CreateView,
	DetailView,
	ListView,
	UpdateView,
)

from channels.models import Channel
from . import forms
from .forms import (
	CustomPasswordChangeForm,
	UpdateUserForm,
)
from .mixins import UserIsOwnerMixin


class LoginUser(
	LoginView,
):
	form_class = forms.LoginUserForm
	template_name = 'app/form.html'
	extra_context = {
		'form_title': 'Вход в аккаунт',
		'submit_button_inner': 'Войти',
	}

class RegisterUser(
	CreateView,
):
	form_class = forms.RegisterUserForm
	template_name = 'app/form.html'
	success_url = reverse_lazy('users:login')
	extra_context = {
		'form_title': 'Регистрация',
		'submit_button_inner': 'Создать аккаунт',
	}
	
	def get_success_url(self):
		messages.success(
			request=self.request,
			message='Вы успешно зарегистрированы!',
		)
		return super().get_success_url()


class UserDetailView(
	LoginRequiredMixin,
	DetailView,
):
	model = get_user_model()
	template_name = 'users/detail.html'
	

class UserUpdateView(
	LoginRequiredMixin,
	UserIsOwnerMixin,
	UpdateView,
):
	model = get_user_model()
	template_name = 'users/update.html'
	form = UpdateUserForm
	fields = [
		'username',
		'email',
		'first_name',
		'last_name',
	]
	extra_context = {
		'form_title': 'Изменение профиля',
		'submit_button_inner': 'Сохранить',
	}
	def get_success_url(self):
		return reverse(
			viewname='users:detail',
			kwargs={
				'pk': self.object.pk,
			}
		)
	

class CustomPasswordChangeView(
	LoginRequiredMixin,
	UserIsOwnerMixin,
	PasswordChangeView,
):
	form_class = CustomPasswordChangeForm
	template_name = 'users/password-change.html'
	extra_context = {
		'form_title': 'Смена пароля',
		'submit_button_inner': 'Изменить пароль',
	}
	success_url = reverse_lazy(
		viewname='users:password-change-done',
	)


class CustomPasswordChangeDoneView(
	PasswordChangeDoneView,
):
	template_name = 'users/password-change-done.html'


-------------------- File: .\users\__init__.py --------------------


-------------------- File: .\users\migrations\0001_initial.py --------------------
# Generated by Django 5.1.4 on 2025-03-04 12:55

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
import users.models
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('photo', models.ImageField(blank=True, null=True, upload_to=users.models.user_avatar_path, verbose_name='Аватарка')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'Пользователь',
                'verbose_name_plural': 'Пользователи',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


-------------------- File: .\users\migrations\__init__.py --------------------


-------------------- File: .\users\templatetags\users_tags.py --------------------
from django import template

register = template.Library()


@register.inclusion_tag(
	filename='users/inclusion/inline.html'
)
def show_user_inline(
	user,
):
	return {
		'user': user,
	}


-------------------- File: .\users\templatetags\__init__.py --------------------


